Index: src/main/java/com/yy/leetcode/linkedlist/ReverseasinglylinkedlistTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/yy/leetcode/linkedlist/ReverseasinglylinkedlistTest.java	(date 1584622490438)
+++ src/main/java/com/yy/leetcode/linkedlist/ReverseasinglylinkedlistTest.java	(date 1584622490438)
@@ -0,0 +1,34 @@
+package com.yy.leetcode.linkedlist;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class ReverseasinglylinkedlistTest {
+
+    Reverseasinglylinkedlist reverseasinglylinkedlist = new Reverseasinglylinkedlist();
+
+    /**
+     * Input: 1->2->3->4->5->NULL
+     * Output: 5->4->3->2->1->NULL
+     */
+    @Test
+    public void reverseList() {
+        ListNode listNode = new ListNode(1);
+        listNode.next = new ListNode(2);
+        listNode.next.next = new ListNode(3);
+        listNode.next.next.next = new ListNode(4);
+        listNode.next.next.next.next = new ListNode(5);
+
+        ListNode node = reverseasinglylinkedlist.reverseList(listNode);
+
+        Assert.assertEquals(node.val,5);
+        Assert.assertEquals(node.next.val,4);
+        Assert.assertEquals(node.next.next.val,3);
+        Assert.assertEquals(node.next.next.next.val,2);
+        Assert.assertEquals(node.next.next.next.next.val,1);
+
+
+    }
+}
\ No newline at end of file
Index: src/main/java/com/yy/leetcode/Tree/SymmetricTreeTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/yy/leetcode/Tree/SymmetricTreeTest.java	(date 1584445986962)
+++ src/main/java/com/yy/leetcode/Tree/SymmetricTreeTest.java	(date 1584445986962)
@@ -0,0 +1,50 @@
+package com.yy.leetcode.Tree;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class SymmetricTreeTest {
+
+    SymmetricTree symmetricTree = new SymmetricTree();
+
+    @Test
+    public void isSymmetric() {
+        TreeNode root = new TreeNode(10);
+
+        root.left = new TreeNode(5);
+        root.right = new TreeNode(15);
+
+        root.left.left = new TreeNode(3);
+        root.left.right = new TreeNode(7);
+
+        root.right.left = null;
+        root.right.right = new TreeNode(18);
+
+        Assert.assertEquals(false,symmetricTree.isSymmetric(root));
+    }
+
+    @Test
+    public void isSymmetric1() {
+        TreeNode root = new TreeNode(1);
+
+        root.left = new TreeNode(2);
+        root.right = new TreeNode(2);
+
+        root.left.left = new TreeNode(3);
+        root.left.right = new TreeNode(4);
+
+        root.right.left = new TreeNode(4);
+        root.right.right = new TreeNode(3);
+
+        Assert.assertEquals(true,symmetricTree.isSymmetric(root));
+    }
+
+    @Test
+    public void isSymmetric2() {
+        TreeNode root = new TreeNode(1);
+        Assert.assertEquals(true,symmetricTree.isSymmetric(root));
+        Assert.assertEquals(false,symmetricTree.isSymmetric(null));
+    }
+}
\ No newline at end of file
Index: src/main/java/com/yy/leetcode/linkedlist/ReverseNodesinkGroup.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/yy/leetcode/linkedlist/ReverseNodesinkGroup.java	(date 1584769160843)
+++ src/main/java/com/yy/leetcode/linkedlist/ReverseNodesinkGroup.java	(date 1584769160843)
@@ -0,0 +1,25 @@
+package com.yy.leetcode.linkedlist;
+
+/**
+ * @author youyouhuang
+ * @create 2020-03-21
+ * @desc https://leetcode.com/problems/reverse-nodes-in-k-group/
+ * 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
+ * k 是一个正整数，它的值小于或等于链表的长度。
+ * 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
+ * 示例：
+ * 给你这个链表：1->2->3->4->5
+ * 当 k = 2 时，应当返回: 2->1->4->3->5
+ * 当 k = 3 时，应当返回: 3->2->1->4->5
+ **/
+
+/**
+ * 对于每K个链表group，采用链表反转的方式。
+ */
+public class ReverseNodesinkGroup {
+
+
+    public ListNode reverseKGroup(ListNode head, int k) {
+        return null;
+    }
+}
Index: src/main/java/com/yy/leetcode/math/WaterandJugProblem.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/yy/leetcode/math/WaterandJugProblem.java	(date 1584784673150)
+++ src/main/java/com/yy/leetcode/math/WaterandJugProblem.java	(date 1584784673150)
@@ -0,0 +1,14 @@
+package com.yy.leetcode.math;
+
+/**
+ * @author youyouhuang
+ * @create 2020-03-21
+ * @desc https://leetcode.com/problems/water-and-jug-problem/
+ **/
+
+public class WaterandJugProblem {
+
+    public boolean canMeasureWater(int x, int y, int z) {
+        return false;
+    }
+}
Index: src/main/java/com/yy/leetcode/linkedlist/IntersectionofTwoLinkedLists.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/yy/leetcode/linkedlist/IntersectionofTwoLinkedLists.java	(date 1584796857690)
+++ src/main/java/com/yy/leetcode/linkedlist/IntersectionofTwoLinkedLists.java	(date 1584796857690)
@@ -0,0 +1,21 @@
+package com.yy.leetcode.linkedlist;
+
+/**
+ * @author youyouhuang
+ * @create 2020-03-19
+ * @desc https://leetcode-cn.com/problems/intersection-of-two-linked-lists/
+ *
+ * 编写一个程序，找到两个单链表相交的起始节点。
+ **/
+
+/**
+ * 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
+ * 输出：Reference of the node with value = 8
+ */
+public class IntersectionofTwoLinkedLists {
+
+    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
+        return null;
+    }
+}
+
Index: src/main/java/com/yy/leetcode/Tree/CartesianTree/MaximumBinaryTree.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/yy/leetcode/Tree/CartesianTree/MaximumBinaryTree.java	(date 1584537359843)
+++ src/main/java/com/yy/leetcode/Tree/CartesianTree/MaximumBinaryTree.java	(date 1584537359843)
@@ -0,0 +1,55 @@
+package com.yy.leetcode.Tree.CartesianTree;
+
+/**
+ * @author youyouhuang
+ * @create 2020-03-18
+ * @desc https://leetcode-cn.com/problems/maximum-binary-tree/
+ * <p>
+ * 给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：
+ * <p>
+ * 二叉树的根是数组中的最大元素。
+ * 左子树是通过数组中最大值左边部分构造出的最大二叉树。
+ * 右子树是通过数组中最大值右边部分构造出的最大二叉树。
+ * <p>
+ * 通过给定的数组构建最大二叉树，并且输出这个树的根节点。
+ **/
+
+import com.yy.leetcode.Tree.TreeNode;
+
+/**
+ *生成的树叫笛卡尔树。
+ * 笛卡尔树的树根是这一子树中键值最小（或最大）的元素；且对于某个序列的笛卡尔树，其任一子树的中序遍历恰好是对应了原序列中的一段连续区间
+ */
+public class MaximumBinaryTree {
+
+    public TreeNode constructMaximumBinaryTree(int[] nums) {
+        if (nums == null || nums.length == 0) {
+            return null;
+        }
+        return constructTree(nums, 0, nums.length);
+    }
+
+    private TreeNode constructTree(int[] nums, int start, int end) {
+        if (start == end) {
+            return null;
+        }
+        int j = findMax(nums, start, end);
+        TreeNode root = new TreeNode(nums[j]);
+        root.left = constructTree(nums, start, j);
+        root.right = constructTree(nums, j + 1, end);
+        return root;
+    }
+
+    private int findMax(int[] nums, int start, int end) {
+        int max = Integer.MIN_VALUE;
+        int p = 0;
+        for (int i = start; i < end; i++) {
+            if (nums[i] > max) {
+                max = nums[i];
+                p = i;
+            }
+        }
+        return p;
+    }
+
+}
Index: src/main/java/com/yy/leetcode/math/WaterandJugProblemTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/yy/leetcode/math/WaterandJugProblemTest.java	(date 1584783649700)
+++ src/main/java/com/yy/leetcode/math/WaterandJugProblemTest.java	(date 1584783649700)
@@ -0,0 +1,16 @@
+package com.yy.leetcode.math;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class WaterandJugProblemTest {
+
+    @Test
+    public void canMeasureWater() {
+        WaterandJugProblem waterandJugProblem = new WaterandJugProblem();
+        Assert.assertEquals(true,waterandJugProblem.canMeasureWater(3,5,4));
+        Assert.assertEquals(true,waterandJugProblem.canMeasureWater(5,2,4));
+    }
+}
\ No newline at end of file
Index: src/main/java/com/yy/leetcode/linkedlist/IntersectionofTwoLinkedListsTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/yy/leetcode/linkedlist/IntersectionofTwoLinkedListsTest.java	(date 1584801360589)
+++ src/main/java/com/yy/leetcode/linkedlist/IntersectionofTwoLinkedListsTest.java	(date 1584801360589)
@@ -0,0 +1,18 @@
+package com.yy.leetcode.linkedlist;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class IntersectionofTwoLinkedListsTest {
+
+    IntersectionofTwoLinkedLists intersectionofTwoLinkedLists = new IntersectionofTwoLinkedLists();
+
+    /**
+     * listA = [4,1,8,4,5], listB = [5,0,1,8,4,5]
+     */
+    @Test
+    public void getIntersectionNode() {
+    }
+}
\ No newline at end of file
Index: src/main/java/com/yy/leetcode/linkedlist/Reverseasinglylinkedlist.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/yy/leetcode/linkedlist/Reverseasinglylinkedlist.java	(date 1584623198597)
+++ src/main/java/com/yy/leetcode/linkedlist/Reverseasinglylinkedlist.java	(date 1584623198597)
@@ -0,0 +1,31 @@
+package com.yy.leetcode.linkedlist;
+
+/**
+ * @author youyouhuang
+ * @create 2020-03-19
+ * @desc https://leetcode-cn.com/problems/reverse-linked-list/
+ *
+ * Input: 1->2->3->4->5->NULL
+ * Output: 5->4->3->2->1->NULL
+ **/
+
+public class Reverseasinglylinkedlist {
+
+    //迭代法
+    public ListNode reverseList(ListNode head) {
+
+        ListNode cur = head;
+        ListNode pre = null;
+
+        while(cur != null){
+            ListNode tmp = cur.next;
+            cur.next = pre;
+            pre = cur;
+            cur = tmp;
+        }
+        return pre;
+
+    }
+
+
+}
Index: src/main/java/com/yy/leetcode/Tree/DeleteNodesAndReturnForest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/yy/leetcode/Tree/DeleteNodesAndReturnForest.java	(date 1584851816155)
+++ src/main/java/com/yy/leetcode/Tree/DeleteNodesAndReturnForest.java	(date 1584851816155)
@@ -0,0 +1,28 @@
+package com.yy.leetcode.Tree;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+/**
+ * @author youyouhuang
+ * @create 2020-03-22
+ * @desc https://leetcode-cn.com/problems/delete-nodes-and-return-forest/
+ * <p>
+ * 给出二叉树的根节点 root，树上每个节点都有一个不同的值。
+ * <p>
+ * 如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。
+ * <p>
+ * 返回森林中的每棵树。你可以按任意顺序组织答案。
+ **/
+
+/**
+ * 方法一:顺序遍历
+ * 方法二：宽度搜索
+ */
+public class DeleteNodesAndReturnForest {
+    public List<TreeNode> delNodes(TreeNode root, int[] to_delete) {
+        return null;
+    }
+}
Index: src/main/java/com/yy/leetcode/Tree/SymmetricTree.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.yy.leetcode.Tree;\r\n\r\nimport java.util.LinkedList;\r\n\r\n/**\r\n * @author youyouhuang\r\n * @create 2020-03-17\r\n * @desc https://leetcode.com/problems/symmetric-tree/\r\n * Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\r\n * <p>\r\n * For example, this binary tree [1,2,2,3,4,4,3] is symmetric\r\n **/\r\n\r\npublic class SymmetricTree {\r\n\r\n    //复制一棵树，对两棵树一棵从左边遍历，一棵从右边\r\n    public boolean isSymmetric(TreeNode root) {\r\n        if(root == null){\r\n            return true;\r\n        }\r\n        TreeNode root1 = root;\r\n        return traverseTree(root, root1);\r\n\r\n    }\r\n\r\n    private boolean traverseTree(TreeNode root, TreeNode root1) {\r\n        if (root == null && root1 == null) {\r\n            return true;\r\n        }\r\n        if (root == null || root1 == null) {\r\n            return false;\r\n        }\r\n\r\n        if (root.val != root1.val) {\r\n            return false;\r\n        }\r\n\r\n        return traverseTree(root.left, root1.right) && traverseTree(root.right, root1.left);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/yy/leetcode/Tree/SymmetricTree.java	(revision a94b1dcf13da18dc20d7f5dd75eb3a3526905641)
+++ src/main/java/com/yy/leetcode/Tree/SymmetricTree.java	(date 1584849363999)
@@ -1,7 +1,5 @@
 package com.yy.leetcode.Tree;
 
-import java.util.LinkedList;
-
 /**
  * @author youyouhuang
  * @create 2020-03-17
